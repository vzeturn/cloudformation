AWSTemplateFormatVersion: '2010-09-09'
Description: 'Part 4: CI/CD Pipeline - Optimized with Caching, Error Handling, and Monitoring'

Parameters:
  GitHubConnectionArn:
    Type: String
    Description: ARN of GitHub Connection (CodeStar Connections)
  
  GitHubRepoFrontend:
    Type: String
    Description: GitHub repository for Frontend (owner/repo)
    Default: 'your-org/frontend-repo'
  
  GitHubRepoBackend:
    Type: String
    Description: GitHub repository for Backend (owner/repo)
    Default: 'your-org/backend-repo'
  
  GitHubBranch:
    Type: String
    Default: 'main'
    AllowedValues: ['main', 'master', 'develop']
    Description: GitHub branch to deploy
  
  Environment:
    Type: String
    Default: 'production'
    AllowedValues: ['development', 'staging', 'production']
    Description: Environment name

Conditions:
  IsProduction: !Equals [!Ref Environment, 'production']

Resources:
  # ============================================
  # INITIAL IMAGE BUILD PROJECTS
  # ============================================
  InitialFrontendBuildProject:
    Type: AWS::CodeBuild::Project
    Properties:
      Name: !Sub '${AWS::StackName}-init-frontend'
      Description: Initial placeholder image builder for Frontend
      ServiceRole:
        Fn::ImportValue: !Sub '${AWS::StackName}-CodeBuildRoleArn'
      Artifacts:
        Type: NO_ARTIFACTS
      Environment:
        Type: LINUX_CONTAINER
        ComputeType: BUILD_GENERAL1_SMALL
        Image: aws/codebuild/standard:7.0
        PrivilegedMode: true
        EnvironmentVariables:
          - Name: AWS_REGION
            Value: !Ref AWS::Region
          - Name: AWS_ACCOUNT_ID
            Value: !Ref AWS::AccountId
          - Name: ECR_REPO
            Value:
              Fn::ImportValue: !Sub '${AWS::StackName}-FrontendECRName'
      Source:
        Type: NO_SOURCE
        BuildSpec: |
          version: 0.2
          phases:
            pre_build:
              commands:
                - echo "[INFO] Logging in to Amazon ECR..."
                - aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com
                - REPO_URI=$AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$ECR_REPO
                - echo "[INFO] ECR Repository URI - $REPO_URI"
            build:
              commands:
                - echo "[INFO] Building placeholder frontend image..."
                - |
                  cat > Dockerfile << 'DOCKEREOF'
                  FROM nginx:alpine
                  
                  # Create placeholder HTML
                  RUN echo '<!DOCTYPE html>' > /usr/share/nginx/html/index.html && \
                      echo '<html lang="en">' >> /usr/share/nginx/html/index.html && \
                      echo '<head>' >> /usr/share/nginx/html/index.html && \
                      echo '  <meta charset="UTF-8">' >> /usr/share/nginx/html/index.html && \
                      echo '  <meta name="viewport" content="width=device-width, initial-scale=1.0">' >> /usr/share/nginx/html/index.html && \
                      echo '  <title>Deploying Application</title>' >> /usr/share/nginx/html/index.html && \
                      echo '  <style>' >> /usr/share/nginx/html/index.html && \
                      echo '    body { font-family: Arial, sans-serif; text-align: center; padding: 50px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; margin: 0; }' >> /usr/share/nginx/html/index.html && \
                      echo '    h1 { font-size: 3em; margin-bottom: 0.5em; }' >> /usr/share/nginx/html/index.html && \
                      echo '    p { font-size: 1.2em; }' >> /usr/share/nginx/html/index.html && \
                      echo '    .status { margin-top: 2em; padding: 1em; background: rgba(255,255,255,0.1); border-radius: 8px; }' >> /usr/share/nginx/html/index.html && \
                      echo '  </style>' >> /usr/share/nginx/html/index.html && \
                      echo '</head>' >> /usr/share/nginx/html/index.html && \
                      echo '<body>' >> /usr/share/nginx/html/index.html && \
                      echo '  <h1>ðŸš€ Application Deploying</h1>' >> /usr/share/nginx/html/index.html && \
                      echo '  <p>Your application is being deployed via CI/CD pipeline</p>' >> /usr/share/nginx/html/index.html && \
                      echo '  <div class="status">' >> /usr/share/nginx/html/index.html && \
                      echo '    <p>Status: Waiting for first deployment</p>' >> /usr/share/nginx/html/index.html && \
                      echo '    <p>Push code to GitHub to trigger deployment</p>' >> /usr/share/nginx/html/index.html && \
                      echo '  </div>' >> /usr/share/nginx/html/index.html && \
                      echo '</body>' >> /usr/share/nginx/html/index.html && \
                      echo '</html>' >> /usr/share/nginx/html/index.html
                  
                  # Configure Nginx with health check endpoint
                  RUN echo 'server {' > /etc/nginx/conf.d/default.conf && \
                      echo '    listen 80;' >> /etc/nginx/conf.d/default.conf && \
                      echo '    server_name _;' >> /etc/nginx/conf.d/default.conf && \
                      echo '    ' >> /etc/nginx/conf.d/default.conf && \
                      echo '    location /health {' >> /etc/nginx/conf.d/default.conf && \
                      echo '        access_log off;' >> /etc/nginx/conf.d/default.conf && \
                      echo '        return 200 "healthy\n";' >> /etc/nginx/conf.d/default.conf && \
                      echo '        add_header Content-Type text/plain;' >> /etc/nginx/conf.d/default.conf && \
                      echo '    }' >> /etc/nginx/conf.d/default.conf && \
                      echo '    ' >> /etc/nginx/conf.d/default.conf && \
                      echo '    location / {' >> /etc/nginx/conf.d/default.conf && \
                      echo '        root /usr/share/nginx/html;' >> /etc/nginx/conf.d/default.conf && \
                      echo '        index index.html;' >> /etc/nginx/conf.d/default.conf && \
                      echo '        try_files $uri $uri/ /index.html;' >> /etc/nginx/conf.d/default.conf && \
                      echo '    }' >> /etc/nginx/conf.d/default.conf && \
                      echo '}' >> /etc/nginx/conf.d/default.conf
                  
                  EXPOSE 80
                  CMD ["nginx", "-g", "daemon off;"]
                  DOCKEREOF
                - echo "[INFO] Building Docker image..."
                - docker build -t $REPO_URI:latest -t $REPO_URI:placeholder .
            post_build:
              commands:
                - echo "[INFO] Pushing image to ECR..."
                - docker push $REPO_URI:latest
                - docker push $REPO_URI:placeholder
                - echo "[SUCCESS] Frontend placeholder image pushed successfully"
      TimeoutInMinutes: 15
      LogsConfig:
        CloudWatchLogs:
          Status: ENABLED
          GroupName: !Sub '/aws/codebuild/${AWS::StackName}-init-frontend'
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-init-frontend'
        - Key: Environment
          Value: !Ref Environment

  InitialBackendBuildProject:
    Type: AWS::CodeBuild::Project
    Properties:
      Name: !Sub '${AWS::StackName}-init-backend'
      Description: Initial placeholder image builder for Backend
      ServiceRole:
        Fn::ImportValue: !Sub '${AWS::StackName}-CodeBuildRoleArn'
      Artifacts:
        Type: NO_ARTIFACTS
      Environment:
        Type: LINUX_CONTAINER
        ComputeType: BUILD_GENERAL1_SMALL
        Image: aws/codebuild/standard:7.0
        PrivilegedMode: true
        EnvironmentVariables:
          - Name: AWS_REGION
            Value: !Ref AWS::Region
          - Name: AWS_ACCOUNT_ID
            Value: !Ref AWS::AccountId
          - Name: ECR_REPO
            Value:
              Fn::ImportValue: !Sub '${AWS::StackName}-BackendECRName'
      Source:
        Type: NO_SOURCE
        BuildSpec: |
          version: 0.2
          phases:
            pre_build:
              commands:
                - echo "[INFO] Logging in to Amazon ECR..."
                - aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com
                - REPO_URI=$AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$ECR_REPO
                - echo "[INFO] ECR Repository URI - $REPO_URI"
            build:
              commands:
                - echo "[INFO] Building placeholder backend image..."
                - |
                  cat > Dockerfile << 'DOCKEREOF'
                  FROM node:18-alpine
                  
                  WORKDIR /app
                  
                  # Create package.json
                  RUN echo '{"name":"placeholder-backend","version":"1.0.0","main":"server.js"}' > package.json
                  
                  # Create placeholder server
                  RUN echo "const http = require('http');" > server.js && \
                      echo "const PORT = process.env.PORT || 3000;" >> server.js && \
                      echo "" >> server.js && \
                      echo "const server = http.createServer((req, res) => {" >> server.js && \
                      echo "  res.setHeader('Access-Control-Allow-Origin', '*');" >> server.js && \
                      echo "  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');" >> server.js && \
                      echo "  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');" >> server.js && \
                      echo "  res.setHeader('Content-Type', 'application/json');" >> server.js && \
                      echo "" >> server.js && \
                      echo "  if (req.method === 'OPTIONS') {" >> server.js && \
                      echo "    res.writeHead(200);" >> server.js && \
                      echo "    res.end();" >> server.js && \
                      echo "    return;" >> server.js && \
                      echo "  }" >> server.js && \
                      echo "" >> server.js && \
                      echo "  if (req.url === '/health' || req.url === '/api/health') {" >> server.js && \
                      echo "    res.writeHead(200);" >> server.js && \
                      echo "    res.end(JSON.stringify({" >> server.js && \
                      echo "      status: 'healthy'," >> server.js && \
                      echo "      message: 'Placeholder backend - waiting for pipeline deployment'," >> server.js && \
                      echo "      timestamp: new Date().toISOString()" >> server.js && \
                      echo "    }));" >> server.js && \
                      echo "  } else if (req.url.startsWith('/api/')) {" >> server.js && \
                      echo "    res.writeHead(200);" >> server.js && \
                      echo "    res.end(JSON.stringify({" >> server.js && \
                      echo "      message: 'Application is deploying'," >> server.js && \
                      echo "      status: 'placeholder'," >> server.js && \
                      echo "      timestamp: new Date().toISOString()" >> server.js && \
                      echo "    }));" >> server.js && \
                      echo "  } else {" >> server.js && \
                      echo "    res.writeHead(404);" >> server.js && \
                      echo "    res.end(JSON.stringify({ error: 'Not Found' }));" >> server.js && \
                      echo "  }" >> server.js && \
                      echo "});" >> server.js && \
                      echo "" >> server.js && \
                      echo "server.listen(PORT, '0.0.0.0', () => {" >> server.js && \
                      echo "  console.log(\`[INFO] Placeholder backend running on port \${PORT}\`);" >> server.js && \
                      echo "  console.log('[INFO] Waiting for pipeline to deploy actual application');" >> server.js && \
                      echo "});" >> server.js
                  
                  EXPOSE 3000
                  CMD ["node", "server.js"]
                  DOCKEREOF
                - echo "[INFO] Building Docker image..."
                - docker build -t $REPO_URI:latest -t $REPO_URI:placeholder .
            post_build:
              commands:
                - echo "[INFO] Pushing image to ECR..."
                - docker push $REPO_URI:latest
                - docker push $REPO_URI:placeholder
                - echo "[SUCCESS] Backend placeholder image pushed successfully"
      TimeoutInMinutes: 15
      LogsConfig:
        CloudWatchLogs:
          Status: ENABLED
          GroupName: !Sub '/aws/codebuild/${AWS::StackName}-init-backend'
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-init-backend'
        - Key: Environment
          Value: !Ref Environment

  # ============================================
  # LAMBDA TO TRIGGER INITIAL BUILDS
  # ============================================
  InitialBuildTriggerFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-InitialBuildTrigger'
      Description: Triggers initial placeholder image builds
      Runtime: python3.11
      Handler: index.handler
      Role:
        Fn::ImportValue: !Sub '${AWS::StackName}-LambdaExecRoleArn'
      Timeout: 900
      MemorySize: 256
      Code:
        ZipFile: |
          import json
          import boto3
          import cfnresponse
          import time
          import logging
          
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          codebuild = boto3.client('codebuild')
          
          def handler(event, context):
              logger.info(f"Event: {json.dumps(event)}")
              
              try:
                  request_type = event.get('RequestType', 'Create')
                  
                  # Only run on Create, not Update or Delete
                  if request_type == 'Delete':
                      logger.info("Delete request - no action needed")
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {
                          'Message': 'Cleanup completed'
                      })
                      return
                  
                  if request_type == 'Update':
                      logger.info("Update request - skipping builds")
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {
                          'Message': 'Update - no builds needed'
                      })
                      return
                  
                  # Get project names from resource properties
                  fe_project = event['ResourceProperties']['FrontendProject']
                  be_project = event['ResourceProperties']['BackendProject']
                  
                  logger.info(f"Starting builds for: {fe_project}, {be_project}")
                  
                  # Start builds
                  fe_build = codebuild.start_build(projectName=fe_project)
                  be_build = codebuild.start_build(projectName=be_project)
                  
                  fe_id = fe_build['build']['id']
                  be_id = be_build['build']['id']
                  
                  logger.info(f"Frontend build ID: {fe_id}")
                  logger.info(f"Backend build ID: {be_id}")
                  
                  # Wait for builds to complete (max 10 minutes)
                  max_iterations = 60  # 60 * 10s = 10 minutes
                  iteration = 0
                  
                  fe_status = 'IN_PROGRESS'
                  be_status = 'IN_PROGRESS'
                  
                  while iteration < max_iterations:
                      time.sleep(10)
                      iteration += 1
                      
                      # Check frontend build
                      if fe_status == 'IN_PROGRESS':
                          fe_response = codebuild.batch_get_builds(ids=[fe_id])
                          fe_status = fe_response['builds'][0]['buildStatus']
                          logger.info(f"[{iteration}] Frontend: {fe_status}")
                      
                      # Check backend build
                      if be_status == 'IN_PROGRESS':
                          be_response = codebuild.batch_get_builds(ids=[be_id])
                          be_status = be_response['builds'][0]['buildStatus']
                          logger.info(f"[{iteration}] Backend: {be_status}")
                      
                      # Check if both completed
                      if fe_status not in ['IN_PROGRESS'] and be_status not in ['IN_PROGRESS']:
                          logger.info("Both builds completed")
                          break
                  
                  # Prepare response data
                  response_data = {
                      'FrontendStatus': fe_status,
                      'BackendStatus': be_status,
                      'FrontendBuildId': fe_id,
                      'BackendBuildId': be_id,
                      'Message': f'Builds completed - Frontend: {fe_status}, Backend: {be_status}'
                  }
                  
                  # Always return SUCCESS to not block stack creation
                  # Even if builds fail, ECS services will retry
                  if fe_status == 'SUCCEEDED' and be_status == 'SUCCEEDED':
                      logger.info("âœ… All builds succeeded")
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data)
                  else:
                      logger.warning(f"âš ï¸ Builds completed with status: FE={fe_status}, BE={be_status}")
                      logger.warning("Returning SUCCESS to allow stack creation - ECS will retry")
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data)
                  
              except Exception as e:
                  logger.error(f"âŒ Error: {str(e)}", exc_info=True)
                  # Still return SUCCESS to not block stack creation
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {
                      'Error': str(e),
                      'Message': 'Build trigger failed but allowing stack creation'
                  })
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-InitialBuildTrigger'
        - Key: Environment
          Value: !Ref Environment

  TriggerInitialBuilds:
    Type: Custom::InitialBuildTrigger
    Properties:
      ServiceToken: !GetAtt InitialBuildTriggerFunction.Arn
      FrontendProject: !Ref InitialFrontendBuildProject
      BackendProject: !Ref InitialBackendBuildProject

  # ============================================
  # CODEBUILD PROJECTS FOR PIPELINE
  # ============================================
  FrontendBuildProject:
    Type: AWS::CodeBuild::Project
    DependsOn: TriggerInitialBuilds
    Properties:
      Name: !Sub '${AWS::StackName}-frontend-build'
      Description: Build frontend application from GitHub
      ServiceRole:
        Fn::ImportValue: !Sub '${AWS::StackName}-CodeBuildRoleArn'
      Artifacts:
        Type: CODEPIPELINE
      Cache:
        Type: LOCAL
        Modes:
          - LOCAL_DOCKER_LAYER_CACHE
          - LOCAL_SOURCE_CACHE
      Environment:
        Type: LINUX_CONTAINER
        ComputeType: BUILD_GENERAL1_SMALL
        Image: aws/codebuild/standard:7.0
        PrivilegedMode: true
        EnvironmentVariables:
          - Name: AWS_REGION
            Value: !Ref AWS::Region
          - Name: AWS_ACCOUNT_ID
            Value: !Ref AWS::AccountId
          - Name: ECR_REPO
            Value:
              Fn::ImportValue: !Sub '${AWS::StackName}-FrontendECRName'
          - Name: ENVIRONMENT
            Value: !Ref Environment
      Source:
        Type: CODEPIPELINE
        BuildSpec: |
          version: 0.2
          phases:
            pre_build:
              commands:
                - echo "[INFO] Starting build at $(date)"
                - echo "[INFO] Logging in to Amazon ECR..."
                - aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com
                - REPO_URI=$AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$ECR_REPO
                - COMMIT_HASH=$(echo $CODEBUILD_RESOLVED_SOURCE_VERSION | cut -c 1-7)
                - IMAGE_TAG=${COMMIT_HASH:=latest}
                - echo "[INFO] Image will be tagged as - latest, $IMAGE_TAG"
            build:
              commands:
                - echo "[INFO] Building Docker image..."
                - docker build -t $REPO_URI:latest -t $REPO_URI:$IMAGE_TAG .
                - echo "[SUCCESS] Docker build completed"
            post_build:
              commands:
                - echo "[INFO] Pushing images to Amazon ECR..."
                - docker push $REPO_URI:latest
                - docker push $REPO_URI:$IMAGE_TAG
                - echo "[INFO] Creating imagedefinitions.json..."
                - printf '[{"name":"frontend","imageUri":"%s"}]' $REPO_URI:latest > imagedefinitions.json
                - cat imagedefinitions.json
                - echo "[SUCCESS] Build completed at $(date)"
          artifacts:
            files:
              - imagedefinitions.json
          cache:
            paths:
              - '/root/.docker/**/*'
      TimeoutInMinutes: 30
      LogsConfig:
        CloudWatchLogs:
          Status: ENABLED
          GroupName: !Sub '/aws/codebuild/${AWS::StackName}-frontend'
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-frontend-build'
        - Key: Environment
          Value: !Ref Environment

  BackendBuildProject:
    Type: AWS::CodeBuild::Project
    DependsOn: TriggerInitialBuilds
    Properties:
      Name: !Sub '${AWS::StackName}-backend-build'
      Description: Build backend application from GitHub
      ServiceRole:
        Fn::ImportValue: !Sub '${AWS::StackName}-CodeBuildRoleArn'
      Artifacts:
        Type: CODEPIPELINE
      Cache:
        Type: LOCAL
        Modes:
          - LOCAL_DOCKER_LAYER_CACHE
          - LOCAL_SOURCE_CACHE
      Environment:
        Type: LINUX_CONTAINER
        ComputeType: BUILD_GENERAL1_SMALL
        Image: aws/codebuild/standard:7.0
        PrivilegedMode: true
        EnvironmentVariables:
          - Name: AWS_REGION
            Value: !Ref AWS::Region
          - Name: AWS_ACCOUNT_ID
            Value: !Ref AWS::AccountId
          - Name: ECR_REPO
            Value:
              Fn::ImportValue: !Sub '${AWS::StackName}-BackendECRName'
          - Name: ENVIRONMENT
            Value: !Ref Environment
      Source:
        Type: CODEPIPELINE
        BuildSpec: |
          version: 0.2
          phases:
            pre_build:
              commands:
                - echo "[INFO] Starting build at $(date)"
                - echo "[INFO] Logging in to Amazon ECR..."
                - aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com
                - REPO_URI=$AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$ECR_REPO
                - COMMIT_HASH=$(echo $CODEBUILD_RESOLVED_SOURCE_VERSION | cut -c 1-7)
                - IMAGE_TAG=${COMMIT_HASH:=latest}
                - echo "[INFO] Image will be tagged as - latest, $IMAGE_TAG"
            build:
              commands:
                - echo "[INFO] Building Docker image..."
                - docker build -t $REPO_URI:latest -t $REPO_URI:$IMAGE_TAG .
                - echo "[SUCCESS] Docker build completed"
            post_build:
              commands:
                - echo "[INFO] Pushing images to Amazon ECR..."
                - docker push $REPO_URI:latest
                - docker push $REPO_URI:$IMAGE_TAG
                - echo "[INFO] Creating imagedefinitions.json..."
                - printf '[{"name":"backend","imageUri":"%s"}]' $REPO_URI:latest > imagedefinitions.json
                - cat imagedefinitions.json
                - echo "[SUCCESS] Build completed at $(date)"
          artifacts:
            files:
              - imagedefinitions.json
          cache:
            paths:
              - '/root/.docker/**/*'
      TimeoutInMinutes: 30
      LogsConfig:
        CloudWatchLogs:
          Status: ENABLED
          GroupName: !Sub '/aws/codebuild/${AWS::StackName}-backend'
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-backend-build'
        - Key: Environment
          Value: !Ref Environment

  # ============================================
  # CODEPIPELINE
  # ============================================
  FrontendPipeline:
    Type: AWS::CodePipeline::Pipeline
    DependsOn: TriggerInitialBuilds
    Properties:
      Name: !Sub '${AWS::StackName}-frontend-pipeline'
      RoleArn:
        Fn::ImportValue: !Sub '${AWS::StackName}-CodePipelineRoleArn'
      ArtifactStore:
        Type: S3
        Location:
          Fn::ImportValue: !Sub '${AWS::StackName}-ArtifactBucket'
      Stages:
        - Name: Source
          Actions:
            - Name: SourceAction
              ActionTypeId:
                Category: Source
                Owner: AWS
                Provider: CodeStarSourceConnection
                Version: '1'
              Configuration:
                ConnectionArn: !Ref GitHubConnectionArn
                FullRepositoryId: !Ref GitHubRepoFrontend
                BranchName: !Ref GitHubBranch
                OutputArtifactFormat: CODE_ZIP
                DetectChanges: true
              OutputArtifacts:
                - Name: SourceOutput
        
        - Name: Build
          Actions:
            - Name: BuildAction
              ActionTypeId:
                Category: Build
                Owner: AWS
                Provider: CodeBuild
                Version: '1'
              Configuration:
                ProjectName: !Ref FrontendBuildProject
              InputArtifacts:
                - Name: SourceOutput
              OutputArtifacts:
                - Name: BuildOutput
        
        - Name: Deploy
          Actions:
            - Name: DeployAction
              ActionTypeId:
                Category: Deploy
                Owner: AWS
                Provider: ECS
                Version: '1'
              Configuration:
                ClusterName:
                  Fn::ImportValue: !Sub '${AWS::StackName}-ECSClusterName'
                ServiceName:
                  Fn::ImportValue: !Sub '${AWS::StackName}-FrontendServiceName'
                FileName: imagedefinitions.json
                DeploymentTimeout: 15
              InputArtifacts:
                - Name: BuildOutput
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-frontend-pipeline'
        - Key: Environment
          Value: !Ref Environment

  BackendPipeline:
    Type: AWS::CodePipeline::Pipeline
    DependsOn: TriggerInitialBuilds
    Properties:
      Name: !Sub '${AWS::StackName}-backend-pipeline'
      RoleArn:
        Fn::ImportValue: !Sub '${AWS::StackName}-CodePipelineRoleArn'
      ArtifactStore:
        Type: S3
        Location:
          Fn::ImportValue: !Sub '${AWS::StackName}-ArtifactBucket'
      Stages:
        - Name: Source
          Actions:
            - Name: SourceAction
              ActionTypeId:
                Category: Source
                Owner: AWS
                Provider: CodeStarSourceConnection
                Version: '1'
              Configuration:
                ConnectionArn: !Ref GitHubConnectionArn
                FullRepositoryId: !Ref GitHubRepoBackend
                BranchName: !Ref GitHubBranch
                OutputArtifactFormat: CODE_ZIP
                DetectChanges: true
              OutputArtifacts:
                - Name: SourceOutput
        
        - Name: Build
          Actions:
            - Name: BuildAction
              ActionTypeId:
                Category: Build
                Owner: AWS
                Provider: CodeBuild
                Version: '1'
              Configuration:
                ProjectName: !Ref BackendBuildProject
              InputArtifacts:
                - Name: SourceOutput
              OutputArtifacts:
                - Name: BuildOutput
        
        - Name: Deploy
          Actions:
            - Name: DeployAction
              ActionTypeId:
                Category: Deploy
                Owner: AWS
                Provider: ECS
                Version: '1'
              Configuration:
                ClusterName:
                  Fn::ImportValue: !Sub '${AWS::StackName}-ECSClusterName'
                ServiceName:
                  Fn::ImportValue: !Sub '${AWS::StackName}-BackendServiceName'
                FileName: imagedefinitions.json
                DeploymentTimeout: 15
              InputArtifacts:
                - Name: BuildOutput
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-backend-pipeline'
        - Key: Environment
          Value: !Ref Environment

  # ============================================
  # CLOUDWATCH ALARMS FOR PIPELINE MONITORING
  # ============================================
  FrontendBuildFailureAlarm:
    Type: AWS::CloudWatch::Alarm
    Condition: IsProduction
    Properties:
      AlarmName: !Sub '${AWS::StackName}-frontend-build-failures'
      AlarmDescription: Alert when frontend builds fail
      MetricName: FailedBuilds
      Namespace: AWS/CodeBuild
      Statistic: Sum
      Period: 300
      EvaluationPeriods: 1
      Threshold: 1
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
        - Name: ProjectName
          Value: !Ref FrontendBuildProject
      TreatMissingData: notBreaching

  BackendBuildFailureAlarm:
    Type: AWS::CloudWatch::Alarm
    Condition: IsProduction
    Properties:
      AlarmName: !Sub '${AWS::StackName}-backend-build-failures'
      AlarmDescription: Alert when backend builds fail
      MetricName: FailedBuilds
      Namespace: AWS/CodeBuild
      Statistic: Sum
      Period: 300
      EvaluationPeriods: 1
      Threshold: 1
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
        - Name: ProjectName
          Value: !Ref BackendBuildProject
      TreatMissingData: notBreaching

  FrontendPipelineFailureAlarm:
    Type: AWS::CloudWatch::Alarm
    Condition: IsProduction
    Properties:
      AlarmName: !Sub '${AWS::StackName}-frontend-pipeline-failures'
      AlarmDescription: Alert when frontend pipeline fails
      MetricName: PipelineExecutionFailure
      Namespace: AWS/CodePipeline
      Statistic: Sum
      Period: 300
      EvaluationPeriods: 1
      Threshold: 1
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
        - Name: PipelineName
          Value: !Ref FrontendPipeline
      TreatMissingData: notBreaching

  BackendPipelineFailureAlarm:
    Type: AWS::CloudWatch::Alarm
    Condition: IsProduction
    Properties:
      AlarmName: !Sub '${AWS::StackName}-backend-pipeline-failures'
      AlarmDescription: Alert when backend pipeline fails
      MetricName: PipelineExecutionFailure
      Namespace: AWS/CodePipeline
      Statistic: Sum
      Period: 300
      EvaluationPeriods: 1
      Threshold: 1
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
        - Name: PipelineName
          Value: !Ref BackendPipeline
      TreatMissingData: notBreaching

Outputs:
  FrontendPipelineName:
    Description: Frontend Pipeline Name
    Value: !Ref FrontendPipeline
    Export:
      Name: !Sub '${AWS::StackName}-FrontendPipeline'

  BackendPipelineName:
    Description: Backend Pipeline Name
    Value: !Ref BackendPipeline
    Export:
      Name: !Sub '${AWS::StackName}-BackendPipeline'

  FrontendBuildProjectName:
    Description: Frontend Build Project Name
    Value: !Ref FrontendBuildProject
    Export:
      Name: !Sub '${AWS::StackName}-FrontendBuildProject'

  BackendBuildProjectName:
    Description: Backend Build Project Name
    Value: !Ref BackendBuildProject
    Export:
      Name: !Sub '${AWS::StackName}-BackendBuildProject'

  InitialBuildStatus:
    Description: Initial Build Trigger Status
    Value: !GetAtt TriggerInitialBuilds.Message

  PipelineConsoleURL:
    Description: CodePipeline Console URL
    Value: !Sub 'https://console.aws.amazon.com/codesuite/codepipeline/pipelines?region=${AWS::Region}'